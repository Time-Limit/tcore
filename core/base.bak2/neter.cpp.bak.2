#include "neter.h"
#include <arpa/inet.h>
#include "log.h"

using namespace TCORE;

void Neter::Session::Close()
{
	if(IsClose())
	{
		return ;
	}
	close_flag = false;
	//TODO zmx Neter::ReadyClose(this);
}

void Neter::Session::RegisterRecvEvent()
{
	epoll_event event;
	event.events = EPOLLIN;
	event.data.ptr = this;
	Neter::GetInstance().Ctl(EPOLL_CTL_MOD, fd, &event);
}

void Neter::Session::RegisterSendEvent()
{
	Log::Error("Neter::Session::RegisterSendEvent");
	epoll_event event;
	event.events = EPOLLOUT;
	event.data.ptr = this;
	Neter::GetInstance().Ctl(EPOLL_CTL_MOD, fd, &event);
}

void Neter::Session::Handle(const epoll_event *event)
{
	if(event->events & (EPOLLIN | EPOLLERR | EPOLLHUP))
	{
		NetRecv();
	}
	if(event->events & EPOLLOUT)
	{
		NetSend();
	}

	Log::Debug("Session::Handle, fd=", fd, ", events=0x", std::hex, event->events, std::dec);
}

void Neter::AcceptSession::NetRecv()
{
	int connect_fd = -1;
	struct sockaddr_in accept_addr;
	int server_addr_len;

	for(;;)
	{
		connect_fd = accept(get_fd(), (struct sockaddr *)&accept_addr, (socklen_t *)&server_addr_len);
		if(connect_fd <= 0)
		{
			if(errno != EINTR && errno != EAGAIN)
			{
				Close();
			}
			else
			{
				RegisterRecvEvent();
			}
			break;
		}
		else if(connect_fd > 0)
		{
			ExchangeSession *ptr = new ExchangeSession(connect_fd);
			Log::Error("ExchangeSession, ptr=", std::hex, (ptrdiff_t)ptr, std::dec);
			epoll_event ev;
			ev.events = EPOLLIN|EPOLLOUT|EPOLLET;
			ev.data.ptr = ptr;
			Neter::GetInstance().Ctl(EPOLL_CTL_ADD, ptr->get_fd(), &ev);
			Neter::GetInstance().session_map.insert(std::make_pair(ptr->SID(), ptr));
			accept_handle(ptr->SID());
		}
	}
}

void Neter::ExchangeSession::NetRecv()
{
	if(IsClose()) return ;
	int cnt = 0, per_cnt = 0;
	for(;;)
	{
		per_cnt = read(get_fd(), tmp_buff, TMP_BUFF_SIZE);
		if(per_cnt > 0)
		{
			cnt += per_cnt;
			recv_buff.insert(recv_buff.end(), tmp_buff, per_cnt);
		}
		else if(per_cnt < 0)
		{
			if(errno == EAGAIN || errno == EINTR)
			{
				RegisterRecvEvent();
			}
			else
			{
				Close();
			}
			break;
		}
		else
		{
			break;
		}
	}

	if(cnt > 0)
	{
		if(type_base_ptr)
		{
			type_base_ptr->Seriable(recv_buff);
		}
	}
	else//if(cnt == 0)
	{
		Close();
	}
}

void Neter::ExchangeSession::NetSend()
{
	if(IsClose()) return ;
	MutexGuard guard(send_buff_lock);
	int per_cnt = write(get_fd(), (static_cast<char *>(send_buff.begin())) + cur_cursor, send_buff.size() - cur_cursor);
	if(per_cnt < 0)
	{
		if(errno == EAGAIN || errno == EINTR)
		{
			RegisterSendEvent();
			return ;
		}
		Log::Error("ExchangeSession::NetSend, errno=", errno, ", info=", strerror(errno));
		send_buff.clear();
		cur_cursor = 0;
		Close();
		return ;
	}

	if((size_t)per_cnt == send_buff.size() - cur_cursor)
	{
		cur_cursor = 0;
		send_buff.clear();
		return ;
	}

	cur_cursor += per_cnt;
	RegisterSendEvent();
}

bool Neter::Listen(const char *ip, int port, AcceptHandle handle)
{
	if(!ip)
	{
		Log::Error("AcceptSession::Listen, invalid ip address.");
		return false;
	}

	int sockfd = 0;
	int optval = -1;
	struct sockaddr_in server;
	socklen_t socklen = sizeof(struct sockaddr_in);

	sockfd = socket(PF_INET, SOCK_STREAM, 0);

	if(sockfd < 0)
	{
		Log::Error("AcceptSession::Listen, socket, error=", strerror(errno));
		return false;
	}

	setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
	memset(&server, 0, socklen);
	struct in_addr address;
	if(inet_pton(AF_INET, ip, &address) == -1)
	{
		Log::Error("AcceptSession::inet_pton, ip=", ip, ", error=", strerror(errno));
		return false;
	}
	server.sin_addr.s_addr = address.s_addr;
	server.sin_port = htons(port);
	server.sin_family = AF_INET;

	if(bind(sockfd, (struct sockaddr *)&server, socklen) < 0)
	{
		Log::Error("AcceptSession::Listen, bind, error=", strerror(errno));
		return false ;
	}

	listen(sockfd, 0);
	Log::Debug("AcceptSession::Listen, fd=", sockfd);	

	epoll_event ev;
	ev.events = EPOLLIN|EPOLLET;
	AcceptSession *accept = new AcceptSession(sockfd, handle);
	ev.data.ptr = accept;
	Neter::GetInstance().Ctl(EPOLL_CTL_ADD, accept->get_fd(), &ev);

	return true;
}

bool Neter::Ctl(int op, int fd, struct epoll_event *event)
{
	if(epoll_ctl(epoll_fd, op, fd, event))
	{
		Log::Error("Neter::Ctl, error=", strerror(errno));
		return false;
	}

	return true;
}

void Neter::Wait(time_t timeout)
{
	int result = epoll_wait(epoll_fd, events, EPOLL_EVENT_SIZE, timeout);

	if(result < 0)
	{
		Log::Error("Neter::Wait, errno=", errno, " info=", strerror(errno));
		return ;
	}

	struct epoll_event *begin = events, *end = events + result;

	for(; begin < end; ++begin)
	{
		if(begin->data.ptr)
		{
			static_cast<Session *>(begin->data.ptr)->Handle(begin);
		}
	}

	//SessionSet::iterator it = session_set.begin();
	//SessionSet::iterator ie = session_set.end();
	//
	//for(; it != ie; ++it)
	//{
	//	epoll_event event;
	//	Ctl(EPOLL_CTL_DEL, (*it)->get_fd(), &event);
	//	delete *it;
	//}
	//
	//session_set.clear();
}

Neter::Neter()
: epoll_fd(-1)
, sid_spawner(0)
{
	epoll_fd = epoll_create(1);
	if(epoll_fd == -1)
	{
		Log::Error("Neter::Neter, error=", strerror(errno));
		assert(false);
	}
}

Neter::~Neter()
{
	//delete session ptr
	close(epoll_fd);
}
