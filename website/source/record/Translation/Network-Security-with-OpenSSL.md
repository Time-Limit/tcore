# 网络安全与OpenSSL

### 作者: Pravir Chandra, Matt Messier, John Viega

### 出版社: O Reilly

### 出版时间: 2002.06

### ISBN: 0-596-00270-X

### 页数: 384

OpenSSL 是 SSL/TLS 的一个受欢迎的，高效的，开源的版本，被广泛的应用于安全网络通
信。关于这个主题的唯一指引，《Network Security with OpenSSL》阐述了安全网络通信
中的挑战，并且告诉了你如何使用 OpenSSL 的工具来以最好的姿态迎接这些挑战。本书非
常注重实用，所以仅提供了关于高效安全的使用OpenSSL的所必须的信息。


## 目录
* 第一章 介绍
	* 密码学初探
	* SSL 概览
	* SSL 的一些问题
	* SSL 的短板
	* OpenSSL 基础
	* 加密第三方软件
* 第二章 命令行接口
	* 基础
	* 信息摘要算法
	* 对称加密
	* 公钥加密
	* S/MIME (安全多用途网际邮件扩展协议)
	* 密码和口令
	* 伪随机数生成器的种子
* 第三章 公钥架构
	* 证书
	* 如何获得证书
	* 建立认证机构
* 第四章 支持设施
	* 多线程支持
	* 内部错误处理
	* 抽象的输入输出
	* 随机数生成
	* 任意精度的数学
	* 使用引擎
* 第五章 SSL/TLS 编程
	* 使用 SSL 编程
	* SSL 编程进阶
* 第六章 对称加密
	* 对称加密的概念
	* 使用 EVP API 加密
	* 一些建议
* 第七章 哈希和 MAC
	* 哈希和 MAC 概览
	* 使用 EVP API 进行哈希
	* 使用 MAC
	* 加密 HTTP Cookies
* 第八章 公钥算法
	* 何时使用公约加密
	* Diffie-Hellman
	* 数字签名算法
	* RSA
	* EVP 公钥接口
	* 对象的编解码
* 第九章 在其他语言中使用 OpenSSL(略过)
	* Perl 与 Net::SSLeay
	* Python 与 MCrypto
	* PHP 与 OpenSSL
* 第十章 编程主题进阶
	* 对象的堆栈
	* 配置文件
	* X.509
	* PKCS#7 and S/MIME
	* PKCS#12
* 附录 A
* 后记

# 第一章 介绍

在当今的网络环境中，大多数的应用必须是安全的，加密技术是提供安全的主要工具之一
。加密技术的主要目标包括加密数据，保证数据完整，权限检验，问责机制，可以阻止绝
大多数类型的基于网络的攻击，包括窃听，IP地址欺诈，连接劫持，篡改数据。OpenSSL 
是一个加密库。它实现了工业界最好的算法的实现，包括诸如 3DES，AES 和 RSA 这样的
加密算法，也包括了报文摘要算法和消息认证码。

以一种安全可靠的方式使用加密算法比人们想象的要困难的多。加密协议是一个很难解决
的问题，算法只是加密协议的基石。密码学家们很难设计出一套可以阻止所有已知攻击的
协议。而且开发者往往会给出很糟糕的实现。举个例子，开发者经常依赖于发送前加密，
接收后解密这种简单方法来保护网络通信。这个策略在保证数据完整方面相当失败。很多
情况下，攻击者可以窃听甚至篡改数据。即使协议设计的很好，实现的错误也很常见。大
多数的加密协议的实用性很有限，如保护在线投票。然而，在不安全的媒介上进行安全通
信的协议具有普遍适用性。这是 SSL 协议，以及它的派生协议 TLS 的基本目标：用最少
的加密技术向任意的（基于 TCP 协议的）网络连接提供加密服务。

最终，如果开发者和管理员不需要知道任何关于加密甚至保护他们应用的事情，那就真是
太好了。如果在开发一个程序时，加密就像链接不同的套接字库一样简单，那就真是太好
了。 OpenSSL 尽可能朝着这个理想前进，而且在现实中，即使是 SSL 协议也需要很好的
理解安全原则，以便安全的使用。的确，大量使用了 SSL 的应用更易受到攻击。

尽管如此， SSL 确实让保护网络通信变简单了。使用 SSL 根本不需要知道加密算法是如
何运作的。相反，你只需要明白那些重要算法的基础特性。相似的，开发者也不需要担心
加密协议；使用 SSL 也不需要对其内部的工作方式有任何了解。你只需要了解如何正确地
应用该算法。

本书的目标是记录 OpenSSL 库以及如何正确的使用它。这本书是为从业人员写的，而不是
安全专家。我们将为您解释该如何高效的使用加密，但是我们不想为那些对密码学如何工
作感兴趣的人写一篇全面介绍。为此，我们向您推荐一本由 Bruce Schneier(John Wiley 
& Sons)编写的《 Applied Cryptography 》，我们还推荐 Menezes, van Oorschot 和 
Vanstone 编写的《Applied Cryptography》(CRC Press)。相同的，我们也不会记录 SSL 
协议本身，我们仅记录它的应用。如果你对协议的详细信息感兴趣，我们推荐
Eric Rescorla 的 《SSL and TLS》(Addison-Wesley)。

### 1.1 密码学初探

对于那些以前从未在工作中使用过密码学的人，本章节将为您介绍理解本书其余部分所需
要的基本原理。首先，我们先了解一下密码学旨在解决的问题，然后我们了解一下现代密
码学提供的原语。如果你有了解过密码学基础，你可以跳过该章节。

#### 1.1.1 密码学的目标

密码学最主要的目标就是保护那些在不安全媒介上传递的数据。通常，这些媒介是计算机
网络。

加密算法有很多种，他们都能向应用提供一种或多种下述服务:

##### 保密

即使数据在不安全的媒介上传递，它们也只能由正确的证书来解密。在实践中，这意味者
潜在的攻击者只能看见“被上锁”的混乱数据，而且如果他们没有正确的信息将无法解开这
些数据。在传统的加密算法中，编码过程是私密的。在现代的加密算法中，这是不可行的
。算法是公开的，而且加密秘钥被用在编解码的过程中。唯一需要保密的就是这个秘钥。
除此之外，在一些我们马上就要论证的常见的例子中，并不是所有的秘钥都需要保密。

##### 完整性（防篡改)

数据完整性的基本思想是，一段数据的接受者有办法确定这些数据在一段时间内是否被修
改过。举个例子，完整性检查可用于确保在线路上传输的数据在传输过程中没有被修改过
。许多知名的校验和可以发现甚至修正简单的错误。然而，这些校验和很难发现那些针对
数据的精心修改。一些加密校验和在使用得当的情况下没有这些缺点。但是要注意，这些
编码不能保证数据完整性。所有加密算法都会受到“位翻转”攻击。这是一种通过改变加密
位来改变真实数据的对应位的方法。

##### 身份验证

出于身份认证的目的，加密算法可以帮助验证身份。

##### 不可否认

加密算法可以使 Bob 证明他收到的来自 Alice 的消息是真的来自 Alice。当 Alice 向 
Bob发送一条消息时，她必须承担相应的责任，而且她也无法否认她曾经发过。在现实世界
中，你可以假设一个攻击者不会破坏独有的加密秘钥。SSL 协议不支持“不可否认”特性，
但是可以通过数字签名来很方便的实现。

这些服务可以用来对抗绝大多数的网络攻击，包括：

##### 偷听

攻击者可以监测网络流量，并记录感兴趣的数据，比如信用卡信息。

##### 篡改

攻击者监视网络流量，并且可以恶意修改传输中的数据（举个例子，攻击者可以修改邮
件的内容）。

##### 欺骗

攻击者可以伪造网络数据，让这些数据看起来像是来自不同的网络地址，而不是他真实的
地址。这种攻击方法可以用来阻挠基础主机信息进行身份验证的系统。

##### 劫持

一旦一个合法用户认证，欺诈攻击可以劫持这个链接。

##### 捕获重放

在一些环境中，攻击者可以记录和重放网络事务，从而造成不良影响。举个例子，你在高
价位出售了一股股票。如果网络协议是不安全的，攻击者可以记录这个交易，并且可以在
低价时重现它，往复循环直到你丢失了所有股票。

许多人认为这些攻击在现实生活中是行不通的。然而，这远非现实。特别是由于有dsniff
这样的工具集存在，只要能进入到两个端点之间的任意一个节点，就可以轻而易举的发动
上述的所有攻击。如果你在同一个本地网络中作为端点之一，攻击同样轻而易举。那些可
以通过别人的软件来入侵机器并操纵它们的天才高中生可以很轻松使用那些工具攻击真实
的系统。

传统上讲，诸如 HTTP，SMTP，FTP，NNTP 和 Telnet 这些网络协议都没有提供足够的防御
机制来应对这些攻击。在电子商务兴起于九十年代中期之前，安全并不是最大的问题，尤
其是考虑到互联网本身就是一个分享学术研究和资源的平台。虽然很多协议提供了基于密
码登陆的身份验证，但是他们中的大多数根本没有处理保密性和完整性。从而导致了所有
的攻击都是可能的。此外，身份验证信息通常可以被窥探到。

对于传统的网络协议来讲，SSL 简直就是一份巨大的福利，因为它可以为基于 TCP 的不安
全的协议添加透明的保密性和完整性服务。它也能提供身份验证服务，最重要的是客户端
可以确认它们正在和目标服务器同行，而不是一些在窥探服务器的攻击者。


#### 1.1.2 加密算法

SSL 协议可以满足大多数的加密需求。虽然有时候并不尽善尽美。举个例子，你可能希望
加密位于终端用户浏览器上的 HTTP cookies。 SSL 无法为存贮在磁盘上的文件提供保护
。对于这样的情况，OpenSSL 给出了用于实现 SSL 协议的底层加密算法。

一般来讲，你应该尽可能的避免直接使用加密算法。你不太可能只需选择一个算法就能获
得完全安全的系统并且还能使用它。通常，加密算法被封装到了加密协议中。一个基于加
密的协议会由大量的不明显的错误。这是为什么你应该去选择一个知名的加密协议来完成
你想做的，而不是你自己发明一些东西。事实上，即使是密码学家发明的协议也经常存在
漏洞。

如果没有公开审查，许多使用中的协议也是不安全的。想一下IEEE 802.11无线网络的WEP
协议。WEP 是一个应该向数据提供和物理线路相同级别的保护的协议。这是一个挑战，因
为数据在空气中传播，而不是通过线路。WEP 有一个经验丰富的程序员设计，但是没有征
求任何专业的密码学家或者安全协议开发人员的意见。虽然在一个有着中等安全知识的经
验丰富的开发人员眼里，这个协议看起来很好，但实际上，它完全缺乏安全性。

尽管如此，有时您可能会找到一个可以满足需求的协议，但是却找不到适合您需要的实现
。或者，您可能会发现您的确需要提出自己的协议。对于这些情况，我们编写了 SSL 的加
密 API。

本书会讨论物种加密算法：对称密钥加密，公钥加密，加密哈希算法，消息验证码，数字
签名。


##### 1.1.2.1

对称加密算法用相同的密钥加解密数据。加密数据可以在不安全的媒介中传递，只有持有
相同密钥的人才能解开这些数据，这是通过把密钥和密钥都传入解密算法实现的。显而易
见，只有当密钥仍然是私有的，这个方案才有效。

对称加密算法最主要的缺陷是密钥必须一直保持私有。特别的，替换密码是非常困难的，
因为您通常试图在使用加密保护的统意媒介上交互密钥。在使用该密钥之前，将该密钥以
明文发送出去，这可能会使攻击者在你发送数据之前就保存了这份密钥。

密钥分发问题的一个解决办法是使用密钥交换协议。OpenSSL 提供了 Diffie-Hellman 协
议已完成这个目的，该协议不用在网络上传递密钥就能完成密钥协商。然而，该协议不能
验证和你交换密钥的对端的身份。必须使用魔种身份验证机制来确保您不会和攻击者交换
密钥。

目前，DES3是最保守的对称加密算法。它被广泛使用，但是 AES，这份新的gap及加密标准
，将代替它成为使用最广泛的加密算法。AES 的确比 DES3 快，但是在很长的一段时间内
，对于那些偏执狂 DES3 仍然是最保守的选择。

值得一提的是现在的客户端和服务器大都支持 RC4。它比 DES3 要快，但却很难被正确安
装。对于那些不支持 AES 和 3DES 的软件的兼容问题，RC4非常感兴趣。如果没有一个好
的理由，我们不建议支持其他算法。出于兴趣，我们将在第六章讨论加密算法的选择。

#### 1.1.2.2 公钥加密
公钥加密算法解决了对称加密中的密钥分发问题。最流行的公钥加密方式是，每一方都有
两把钥匙，一个必须保密，另一个可以随意分发。两把钥匙有着很特殊的算术关系。如果
Alice 要对 Bob 发送消息，那她首先要有 Bob 的公钥。她要用 Bob 的公钥加密数据然后
发送。一经加密，则只有支持 Bob 密钥的人才能解开这份加密数据。

公钥加密算法解决了密钥分发问题，有一些办法可以找到 Bob 的公钥并确认这份公钥的确
属于 Bob。在实际生活中，公钥在传递使附带了一些被称为证书的支持信息，这些证书可
以在可信的第三方处验证。一般来说，可信的第三方一般是一个机构，它会核验那些希望
持有他们证书的人是否合法。SSL 通过可信的第三方来解决公钥分发问题。公钥加密算法
有一个显著的缺点，思考一下：如果数据过大，它将会慢的难以忍受。对称密钥加密通常
可以很快完成，以便加密和解密机器可以管理的所有网络通信量。加密算法一般会受限于
加密的速度，而不是进入计算机的带宽，特别是服务器，需要同时处理许多链接。

这导致了现在许多使用公钥加密算法的系统，包括 SSL，都尽可能的少使用它。一般来说
，公钥加密用于在对称算法上商定加密密钥，然后使用对称算法完成所有进一步加密。因
此公钥加密通常用于密钥交换协议和需要不可否认性时。


# 第五章 SSL/TLS 编程

OpenSSL 库最重要的特性就是它实现了 SSL 和 TLS。最开始的时候是 Netscape 为了 WEB
事务开发的，但这个协议逐渐成长为加密流通信的通用解决方案。Netscape 的发布的第一
版 SSL 是 SSLv2。从那时起，安全专家们开始致力于修正 SSLv2 的一些瑕疵，这使得
SSLv2 得以问世。同时，基于 SSL 的传输层安全协议也开发完成了，也就是 TSLv1。因为
SSLv2有着这样或那样的问题，所以现在的应用不应该支持它。在这一章中，我们仅仅讨论
如何使用 OpenSSL 支持的 SSLv3 或者 TSLv1 进行编程。除非特别之处，否则当我们提及
SSL时，是指的 SSLv3 和 TLSv1。

从设计的角度出发，除了在我们应用中用到的 SSL 相关的知识，我们还应该了解一些其他
的。由于协议设置的复杂性，大量的API，和开发者对库函数缺乏经验，所以一份使用 SSL
的程序的正确实现是非常困难的。OpenSSL 的 SSL 支持部分模仿了 Unix 的套接字接口。
然而，当我们开始研究 API 的精华之处时，这些类似就显得微不足道了。为了使熟悉大量
库函数的过程变得简单，我们举了一个简单的例子，例子演示了客户端和服务端如何一
步步的建立基于 SSL 的安全链接。为了帮助理解，我们做了一些现实世界中的程序不会出
现的简单假设。

从这一点出发，我们将逐步缩小与 OpenSSL 的更新进的特性的差距。本章的目标是把库函
数的特点划分成更小的单元以便于建立起对程序的理解。我们希望当开发人员在他们自己
的应用中使用 SSL 时，这份程序会成为他们实现的模板。在向应用程序添加 SSL 时，必
须考虑应用程序的独特需求，必须对安全性和功能性做出最佳决策。

## 5.1 使用 SSL 编程

OpenSSL 中关于 SSL 的 API 对于一个没有经验的开发者来说是非常巨大且令人沮丧的。
此外，正如在第一章中提到的，如果实现不正确，SSL 的安全目标根本无法实现。这些因
素使得开发人员难以完成任务。为了理清实现安全程序的神秘面纱，我们将这个问题分解
三步。在每一步中，开发者都需要向 SSL 提供必须要的信息，以使 SSL 完成它的工作。
举个例子，一个高度兼容的开发者和一个高安全服务应用的开发者所做的完全不同。

下面的步骤为开发人员在实现SSL客户端或服务器时遵循的模板提供了一个模板。我们从一
个小例子开始，并以它为基础。在所有的步骤都经过深思熟虑之前，这个例子的安全性并
不能满足我们。在每一步中，我们将引入一小部分 API。在所有的步骤之后，开发者应该
能更清楚的全盘思考如何去设计一个内置 SSL 的应用。在完成所有的步骤之后，路还有很
长。为了满足许多应用程序的要求，我们应该走的更远，应该去看看 API 的高级特性。

### 5.1.1 加密应用程序

我们先使用两个很简单的程序：一个客户端和服务器，服务器只简单的将来自客户端的数
据传给控制台。我们的目标是不断改善这两个程序，以使得他们能在敌对的环境中完成任
务。换句话说，我们将使两个程序都对对端进行严格的身份链接。在我们逐步实现内置
SSL 的程序的过程中，我们将讨论开发者在每个阶段所必须做的抉择。

在开始之前，让我们先看一下我们的程序。总共有四个文件：common.h， common.c，
client.c 和 server.c 。所有的代码都在 例5-1 到 例5-4 中。我们也会用 例4-2 中的
代码，以使得我们可以使用多线程。在 Unix systems，我们会继续使用 POSIX 线程。

在 例5-1 中展示的 common.h，第一至五行包含了 OpenSSL 有关的头文件。现在我们不会
用到这些头文件中的任何代码，但是我们在后面会用到，所以把他们包含进来了。第22至
24行定义了客户端和服务器会用到的字符串和服务器监听的端口。另外，为了方便错误处
理和像第四章那样为了线程是平台无关的，头文件还包含了一些定义。

```

例5-1

#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#ifndef WIN32
#include <pthread.h>
#define THREAD_CC
#define THREAD_TYPE pthread_t
#define THREAD_CREATE(tid, entry, arg) pthread_create(&(tid), NULL, \
(entry), (arg))
#else
#include <windows.h>
#define THREAD_CC _ _cdecl
#define THREAD_TYPE DWORD
#define THREAD_CREATE(tid, entry, arg) do { _beginthread((entry), 0,
(arg));\
(tid) =
GetCurrentThreadId(); \
} while (0)
#endif

#define PORT "6001"
#define SERVER "splat.zork.org"
#define CLIENT "shell.zork.org"

#define int_error(msg) handle_error(__FILE__, __LINE_ _, msg)
void handle_error(const char *file, int lineno, const char *msg);

void init_OpenSSL(void);

```

例5-2中的 common.c，定义了我们的错误报告函数 handle_error。我们例子中的错误处理
有一点严厉，在你自己的应用例你或许会用一些对用户有好的错误处理方式。一般来说，
通过使应用程序终端处理所有可能的错误是不合适的。

common.h 也定义了一个函数，这个函数完成诸如 设置 OpenSSL 的多线程，初始化库函数
，加载错误字符串等任务。调用 SSL_load_error_strings 已加载错误码的相关数据，这
样当错误发生的时候，就可以打印错误堆栈了，我们可以得到易于阅读的关于错误的信息
。加载这些诊断用的字符串会占用内存，当我们开发一些诸如内存受限的内置系统或者机
器的时候就不会加载这些字符串。一般来说，加载这些字符串是一个好主意，因为这会使
调试变得简单。

当我们在添加 SSL 相关功能时，common.c 里有客户端和服务器都需要的函数的定义，函
数的声明在 common.h。

```
例5-2

#include "common.h"

void handle_error(const char *file, int lineno, const char *msg)
{
	fprintf(stderr, "** %s:%i %s\n", file, lineno, msg);
	ERR_print_errors_fp(stderr);
	exit(-1);
}

void init_OpenSSL(void)
{
	if (!THREAD_setup() || ! SSL_library_init())
	{
		fprintf(stderr, "** OpenSSL initialization failed!\n");
		exit(-1);
	}
	SSL_load_error_strings();
}
```

客户端的大部分代码——client.c，在例5-3中。它创建了一个连向服务器6001端口的链接，
这个端口定义在 common.h 中。当一个链接建立后，它开始从标准输入读入数据知道遇到
EOF。当数据被读入并被填到缓冲区后，数据将通过链接被发送到服务端。这里应该注意一
下，虽然我们使用了 OpenSSL 进行套接字传输，但我们仍然没有使用 SSL 协议。

第27到29行创建了一个 BIO 对象，包含了一个从 BIO_s_connect 返回的 BIO_METHOD；调
用 BIO_new_connect 可以很轻松的完成这个任务。只要没有错误发生，31到32行将进行
TCP 链接并且检查错误。当一个链接建立完成后，会调用 do_client_loop，这个函数会一
直从标准输入读取数据并写入到套接字。当发生错误或者从控制台读到 EOF，这个函数会
退出并且程序会终止。

```
例5-3

#include "common.h"

void do_client_loop(BIO *conn)
{
	int err, nwritten;
	char buf[80];

	for (;;)
	{
		if (!fgets(buf, sizeof(buf), stdin))
		break;
		for (nwritten = 0; nwritten < sizeof(buf); nwritten +=err)
		{
			err = BIO_write(conn, buf + nwritten, strlen(buf)
				- nwritten);
			if (err <= 0)
			return;
		}
	}
}

int main(int argc, char *argv[])
{
	BIO *conn;

	init_OpenSSL();

	conn = BIO_new_connect(SERVER ":" PORT);
	if (!conn)
	int_error("Error creating connection BIO");

	if (BIO_do_connect(conn) <= 0)
	int_error("Error connecting to remote machine");

	fprintf(stderr, "Connection opened\n");
	do_client_loop(conn);
	fprintf(stderr, "Connection closed\n");

	BIO_free(conn);
	return 0;
}
```


